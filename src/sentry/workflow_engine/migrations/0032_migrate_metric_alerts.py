# Generated by Django 5.1.5 on 2025-02-10 19:33

import dataclasses
import logging
from enum import Enum, IntEnum
from typing import Any

from django.apps.registry import Apps
from django.db import migrations
from django.db.backends.base.schema import BaseDatabaseSchemaEditor

from sentry.integrations.services.integration import integration_service
from sentry.new_migrations.migrations import CheckedMigration
from sentry.utils.query import RangeQuerySetWrapperWithProgressBarApprox
from sentry.workflow_engine.typings.notification_action import SentryAppDataBlob

logger = logging.getLogger(__name__)


class PriorityLevel(IntEnum):
    LOW = 25
    MEDIUM = 50
    HIGH = 75


class DetectorPriorityLevel(IntEnum):
    OK = 0
    LOW = PriorityLevel.LOW
    MEDIUM = PriorityLevel.MEDIUM
    HIGH = PriorityLevel.HIGH


class IncidentStatus(Enum):
    OPEN = 1
    CLOSED = 2
    WARNING = 10
    CRITICAL = 20


class AlertRuleStatus(Enum):
    PENDING = 0
    SNAPSHOT = 4
    DISABLED = 5
    NOT_ENOUGH_DATA = 6


FIELDS_TO_DETECTOR_FIELDS = {
    "name": "name",
    "description": "description",
    "user_id": "owner_user_id",
    "team_id": "owner_team_id",
}

PRIORITY_MAP = {
    "warning": DetectorPriorityLevel.MEDIUM,
    "critical": DetectorPriorityLevel.HIGH,
}


def migrate_metric_alerts(apps: Apps, schema_editor: BaseDatabaseSchemaEditor) -> None:
    AlertRule = apps.get_model("sentry", "AlertRule")
    AlertRuleProjects = apps.get_model("sentry", "AlertRuleProjects")
    AlertRuleTrigger = apps.get_model("sentry", "AlertRuleTrigger")
    AlertRuleTriggerAction = apps.get_model("sentry", "AlertRuleTriggerAction")
    AlertRuleActivity = apps.get_model("sentry", "AlertRuleActivity")
    MetricAlertFire = apps.get_model("sentry", "MetricAlertFire")
    RuleSnooze = apps.get_model("sentry", "RuleSnooze")
    QuerySubscription = apps.get_model("sentry", "QuerySubscription")
    Incident = apps.get_model("sentry", "Incident")

    Action = apps.get_model("workflow_engine", "Action")
    ActionAlertRuleTriggerAction = apps.get_model("workflow_engine", "ActionAlertRuleTriggerAction")
    AlertRuleDetector = apps.get_model("workflow_engine", "AlertRuleDetector")
    AlertRuleWorkflow = apps.get_model("workflow_engine", "AlertRuleWorkflow")
    DataCondition = apps.get_model("workflow_engine", "DataCondition")
    DataConditionGroup = apps.get_model("workflow_engine", "DataConditionGroup")
    DataConditionGroupAction = apps.get_model("workflow_engine", "DataConditionGroupAction")
    DataSource = apps.get_model("workflow_engine", "DataSource")
    Detector = apps.get_model("workflow_engine", "Detector")
    DetectorState = apps.get_model("workflow_engine", "DetectorState")
    DetectorWorkflow = apps.get_model("workflow_engine", "DetectorWorkflow")
    Workflow = apps.get_model("workflow_engine", "Workflow")
    WorkflowDataConditionGroup = apps.get_model("workflow_engine", "WorkflowDataConditionGroup")

    for alert_rule in RangeQuerySetWrapperWithProgressBarApprox(
        AlertRule.objects_with_snapshots.all()
    ):
        if alert_rule.status in [AlertRuleStatus.DISABLED, AlertRuleStatus.SNAPSHOT]:
            continue

        organization_id = alert_rule.organization_id
        project = alert_rule.projects.get()
        snoozed = None
        try:
            snoozed = RuleSnooze.objects.get(alert_rule_id=alert_rule.id, user_id=None)
        except RuleSnooze.DoesNotExist:
            pass
        enabled = True if snoozed is not None else False

        # create data source
        snuba_query = alert_rule.snuba_query
        if not snuba_query:
            logger.info("alert rule missing snuba query", extra={"alert_rule_id": alert_rule.id})
            continue
        try:
            query_subscription = QuerySubscription.objects.get(snuba_query=snuba_query.id)
        except QuerySubscription.DoesNotExist:
            logger.info(
                "query subscription does not exist", extra={"snuba_query_id": snuba_query.id}
            )
            continue
        data_source = DataSource.objects.create(
            organization_id=organization_id,
            source_id=str(query_subscription.id),
            type="snuba_query_subscription",
        )

        # create DCG
        data_condition_group = DataConditionGroup.objects.create(
            organization_id=organization_id,
        )
        # create detector
        detector = Detector.objects.create(
            project_id=project.id,
            enabled=enabled,
            created_by_id=None,
            name=alert_rule.name,
            workflow_condition_group=data_condition_group,
            type=MetricAlertFire.slug,
            description=alert_rule.description,
            owner_user_id=alert_rule.user_id,
            owner_team=alert_rule.team,
            config={
                "threshold_period": alert_rule.threshold_period,
                "sensitivity": alert_rule.sensitivity,
                "seasonality": alert_rule.seasonality,
                "comparison_delta": alert_rule.comparison_delta,
                "detection_type": alert_rule.detection_type,
            },
        )
        # create workflow
        workflow = Workflow.objects.create(
            name=alert_rule.name,
            organization_id=organization_id,
            when_condition_group=None,
            enabled=enabled,
            created_by_id=None,
            config={},
        )

        open_incident = Incident.objects.get_active_incident(alert_rule, project)
        if open_incident:
            state = (
                DetectorPriorityLevel.MEDIUM
                if open_incident.status == IncidentStatus.WARNING.value
                else DetectorPriorityLevel.HIGH
            )
        else:
            state = DetectorPriorityLevel.OK

        data_source.detectors.set([detector])
        # create detector state
        detector_state = DetectorState.objects.create(
            detector=detector,
            active=False,
            state=state,
        )
        # create lookup tables
        alert_rule_detector = AlertRuleDetector.objects.create(
            alert_rule=alert_rule, detector=detector
        )
        alert_rule_workflow = AlertRuleWorkflow.objects.create(
            alert_rule=alert_rule, workflow=workflow
        )
        detector_workflow = DetectorWorkflow.objects.create(detector=detector, workflow=workflow)


class Migration(CheckedMigration):
    # This flag is used to mark that a migration shouldn't be automatically run in production.
    # This should only be used for operations where it's safe to run the migration after your
    # code has deployed. So this should not be used for most operations that alter the schema
    # of a table.
    # Here are some things that make sense to mark as post deployment:
    # - Large data migrations. Typically we want these to be run manually so that they can be
    #   monitored and not block the deploy for a long period of time while they run.
    # - Adding indexes to large tables. Since this can take a long time, we'd generally prefer to
    #   run this outside deployments so that we don't block them. Note that while adding an index
    #   is a schema change, it's completely safe to run the operation after the code has deployed.
    # Once deployed, run these manually via: https://develop.sentry.dev/database-migrations/#migration-deployment

    is_post_deployment = True

    dependencies = [
        ("workflow_engine", "0029_ds_query_id_to_pending"),
    ]

    operations = [
        migrations.RunPython(
            migrate_metric_alerts,
            migrations.RunPython.noop,
            hints={"tables": ["sentry_alertrule"]},
        ),
    ]
